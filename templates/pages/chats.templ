package pages

templ Speak() {
	<script>
	    let speakws = new WebSocket("/speak/ws");
	    speakws.binaryType = "arraybuffer";
	    let audioContext = new (window.AudioContext || window.webkitAudioContext)();
	    const sampleRate = 16000;
		let lastPlaybackTime = audioContext.currentTime;
		let buffer = new Int16Array(0);
		let lastBufferTime = null;
		const waitDurationMS = 500;

		speakws.onopen = () => {
            console.log("WebSocket connected");
            startSpeakingAudioStream(sendData, sampleRate);
		};
	    speakws.onmessage = (e) => {
            console.log("Playing received audio");
            // decodeAndScheduleWav(e.data);
            scheduleBuffer(e.data)
	    };
	    speakws.onerror = (err) => console.error("WS error", err);

		setInterval(() => {
		    // if user has not spoken for waitDurationMS, send the buffer and play the response
			if (lastBufferTime && Date.now() - lastBufferTime > waitDurationMS) {
			    lastBufferTime = null;
				const wavData = pcmToWav(buffer, sampleRate, 1, 16)
				speakws.send(wavData);
				buffer = new Int16Array(0);
			}
		}, 50);

		function sendData(data) {
		    speakws.send(data); // use to send to the server consistently
		    // addBuffer(data) // use this to send data only when user has not spoken for waitDurationMS
		}

		function addBuffer(data) {
			newBuffer = new Int16Array(buffer.length + data.length);
			newBuffer.set(buffer, 0);
			newBuffer.set(data, buffer.length);
			buffer = newBuffer;
			lastBufferTime = Date.now();
		}

		function scheduleBuffer(buf) {
		    if (!buf || buf.length === 0) {
				console.warn("Empty buffer received");
				return;
		    }
            int16Array = new Int16Array(buf);
		    const floatData = new Float32Array(int16Array.length);
		    for (let i = 0; i < int16Array.length; i++) {
                floatData[i] = int16Array[i] < 0
                    ? int16Array[i] / 32768
                    : int16Array[i] / 32767;
		    }

		    const audioBuffer = audioContext.createBuffer(1, floatData.length, sampleRate);
		    audioBuffer.getChannelData(0).set(floatData);

		    const source = audioContext.createBufferSource();
		    source.buffer = audioBuffer;
		    source.connect(audioContext.destination);

			const now = audioContext.currentTime;
			if (lastPlaybackTime < now) {
                lastPlaybackTime = now;
			}

		    // Schedule it to play after the previous chunk
		    source.start(lastPlaybackTime);
		    lastPlaybackTime += audioBuffer.duration;
		}

		function decodeAndScheduleWav(base64Audio) {
		    if (!base64Audio) {
                console.warn("Empty audio input");
                return;
		    }

		    // const arrayBuffer = base64ToArrayBuffer();
		    const arrayBuffer = base64ToArrayBuffer(base64Audio);

		    audioContext.decodeAudioData(arrayBuffer, (audioBuffer) => {
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);

            const now = audioContext.currentTime;
            if (lastPlaybackTime < now) {
                lastPlaybackTime = now;
            }

            source.start(lastPlaybackTime);
            lastPlaybackTime += audioBuffer.duration;
		    }, (error) => {
                console.error("Failed to decode audio:", error);
		    });
}
	</script>
	<div class="bg-black h-screen"/>
}

templ TextChat() {
	<script>
		let webtextws = new WebSocket("/web_text/ws");
		webtextws.binaryType = "arraybuffer";
		webtextws.onopen = () => {
		    console.log("WebSocket connected")
		}
		webtextws.onmessage = (e) => {
            const text = new TextDecoder("utf-8").decode(e.data);
			document.getElementById("textWebResponse").innerText = text;
		}
		webtextws.onerror = (err) => console.error("WS error", err)
		async function SendInput() {
		    const el = document.getElementById("textWeb")
			if (!el || el.value == "") {
			    console.error("no value")
				return
			}
			if (webtextws.readyState == WebSocket.OPEN) {
			    webtextws.send(el.value)
			} else {
			    console.error("WS NOT OPEN")
			}
		}
	</script>
	<div class="flex flex-col gap-2 bg-black h-screen text-white">
		<button onclick="SendInput()" class="border border-gray-100">Text</button>
		<textarea id="textWeb" rows="15" class="border border-gray-100"></textarea>
			response
		<textarea id="textWebResponse" rows="15" class="border border-gray-100"></textarea>
	</div>
}
